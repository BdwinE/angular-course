{"ast":null,"code":"import { inject } from '@angular/core';\nimport { Actions, createEffect, ofType } from '@ngrx/effects';\nimport * as AuthActions from '../../actions/auth.actions';\nimport { catchError, map, of, switchMap, tap } from 'rxjs';\nimport { environment } from 'src/environments/environment';\nimport { HttpClient } from '@angular/common/http';\nimport { User } from 'src/app/auth/user.model';\nimport { AuthService } from 'src/app/auth/auth.service';\nexport const authSignup = createEffect((actions$ = inject(Actions), http = inject(HttpClient), authService = inject(AuthService)) => {\n  return actions$.pipe(ofType(AuthActions.SIGNUP_START), switchMap(signupAction => {\n    return http.post('https://www.googleapis.com/identitytoolkit/v3/relyingparty/signupNewUser?key=' + environment.firebaseAPIKey, {\n      email: signupAction['email'],\n      password: signupAction['password'],\n      returnSecureToken: true\n    }).pipe(tap(resData => {\n      authService.setLogoutTimer(+resData.expiresIn * 1000);\n    }), map(resData => {\n      const expirationDate = new Date(new Date().getTime() + +resData.expiresIn * 1000);\n      const newUser = new User(resData.email, resData.localId, resData.idToken, expirationDate);\n      localStorage.setItem('UserData', JSON.stringify(newUser));\n      return AuthActions.authenticateAction({\n        user: newUser\n      });\n    }), catchError(errorRes => {\n      let errorMessage = 'An unknown error occurred!';\n      if (!errorRes.error || !errorRes.error.error) {\n        return of(AuthActions.authenticateFailAction({\n          payload: errorMessage\n        }));\n      }\n      switch (errorRes.error.error.message) {\n        case 'EMAIL_EXISTS':\n          errorMessage = 'This email exists already';\n          break;\n        case 'EMAIL_NOT_FOUND':\n          errorMessage = 'This email does not exist.';\n          break;\n        case 'INVALID_PASSWORD':\n          errorMessage = 'This password is not correct.';\n          break;\n      }\n      return of(AuthActions.authenticateFailAction({\n        payload: errorMessage\n      }));\n    }));\n  }));\n}, {\n  functional: true,\n  dispatch: true\n});","map":{"version":3,"names":["inject","Actions","createEffect","ofType","AuthActions","catchError","map","of","switchMap","tap","environment","HttpClient","User","AuthService","authSignup","actions$","http","authService","pipe","SIGNUP_START","signupAction","post","firebaseAPIKey","email","password","returnSecureToken","resData","setLogoutTimer","expiresIn","expirationDate","Date","getTime","newUser","localId","idToken","localStorage","setItem","JSON","stringify","authenticateAction","user","errorRes","errorMessage","error","authenticateFailAction","payload","message","functional","dispatch"],"sources":["C:\\Users\\asolu\\PersonalDevProjects\\Udemy\\Angular-The_Complete_Guide_2023_Edition\\ngrx-00-starting-project\\src\\app\\store\\effects\\auth\\auth-signup.effect.ts"],"sourcesContent":["import { inject } from '@angular/core';\r\nimport { Actions, createEffect, ofType } from '@ngrx/effects';\r\nimport * as AuthActions from '../../actions/auth.actions';\r\nimport { catchError, map, of, switchMap, tap } from 'rxjs';\r\nimport { environment } from 'src/environments/environment';\r\nimport { AuthResponseData } from './auth-login.effect';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { User } from 'src/app/auth/user.model';\r\nimport { AuthService } from 'src/app/auth/auth.service';\r\n\r\nexport const authSignup = createEffect(\r\n  (\r\n    actions$ = inject(Actions),\r\n    http = inject(HttpClient),\r\n    authService = inject(AuthService)\r\n  ) => {\r\n    return actions$.pipe(\r\n      ofType(AuthActions.SIGNUP_START),\r\n      switchMap((signupAction: AuthActions.signupStart) => {\r\n        return http\r\n          .post<AuthResponseData>(\r\n            'https://www.googleapis.com/identitytoolkit/v3/relyingparty/signupNewUser?key=' +\r\n              environment.firebaseAPIKey,\r\n            {\r\n              email: signupAction['email'],\r\n              password: signupAction['password'],\r\n              returnSecureToken: true,\r\n            }\r\n          )\r\n          .pipe(\r\n            tap((resData) => {\r\n              authService.setLogoutTimer(+resData.expiresIn * 1000);\r\n            }),\r\n            map((resData) => {\r\n              const expirationDate = new Date(\r\n                new Date().getTime() + +resData.expiresIn * 1000\r\n              );\r\n              const newUser = new User(\r\n                resData.email,\r\n                resData.localId,\r\n                resData.idToken,\r\n                expirationDate\r\n              );\r\n              localStorage.setItem('UserData', JSON.stringify(newUser));\r\n              return AuthActions.authenticateAction({ user: newUser });\r\n            }),\r\n            catchError((errorRes) => {\r\n              let errorMessage = 'An unknown error occurred!';\r\n              if (!errorRes.error || !errorRes.error.error) {\r\n                return of(\r\n                  AuthActions.authenticateFailAction({\r\n                    payload: errorMessage,\r\n                  })\r\n                );\r\n              }\r\n              switch (errorRes.error.error.message) {\r\n                case 'EMAIL_EXISTS':\r\n                  errorMessage = 'This email exists already';\r\n                  break;\r\n                case 'EMAIL_NOT_FOUND':\r\n                  errorMessage = 'This email does not exist.';\r\n                  break;\r\n                case 'INVALID_PASSWORD':\r\n                  errorMessage = 'This password is not correct.';\r\n                  break;\r\n              }\r\n              return of(\r\n                AuthActions.authenticateFailAction({ payload: errorMessage })\r\n              );\r\n            })\r\n          );\r\n      })\r\n    );\r\n  },\r\n  { functional: true, dispatch: true }\r\n);\r\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,eAAe;AACtC,SAASC,OAAO,EAAEC,YAAY,EAAEC,MAAM,QAAQ,eAAe;AAC7D,OAAO,KAAKC,WAAW,MAAM,4BAA4B;AACzD,SAASC,UAAU,EAAEC,GAAG,EAAEC,EAAE,EAAEC,SAAS,EAAEC,GAAG,QAAQ,MAAM;AAC1D,SAASC,WAAW,QAAQ,8BAA8B;AAE1D,SAASC,UAAU,QAAQ,sBAAsB;AACjD,SAASC,IAAI,QAAQ,yBAAyB;AAC9C,SAASC,WAAW,QAAQ,2BAA2B;AAEvD,OAAO,MAAMC,UAAU,GAAGZ,YAAY,CACpC,CACEa,QAAQ,GAAGf,MAAM,CAACC,OAAO,CAAC,EAC1Be,IAAI,GAAGhB,MAAM,CAACW,UAAU,CAAC,EACzBM,WAAW,GAAGjB,MAAM,CAACa,WAAW,CAAC,KAC/B;EACF,OAAOE,QAAQ,CAACG,IAAI,CAClBf,MAAM,CAACC,WAAW,CAACe,YAAY,CAAC,EAChCX,SAAS,CAAEY,YAAqC,IAAI;IAClD,OAAOJ,IAAI,CACRK,IAAI,CACH,+EAA+E,GAC7EX,WAAW,CAACY,cAAc,EAC5B;MACEC,KAAK,EAAEH,YAAY,CAAC,OAAO,CAAC;MAC5BI,QAAQ,EAAEJ,YAAY,CAAC,UAAU,CAAC;MAClCK,iBAAiB,EAAE;KACpB,CACF,CACAP,IAAI,CACHT,GAAG,CAAEiB,OAAO,IAAI;MACdT,WAAW,CAACU,cAAc,CAAC,CAACD,OAAO,CAACE,SAAS,GAAG,IAAI,CAAC;IACvD,CAAC,CAAC,EACFtB,GAAG,CAAEoB,OAAO,IAAI;MACd,MAAMG,cAAc,GAAG,IAAIC,IAAI,CAC7B,IAAIA,IAAI,EAAE,CAACC,OAAO,EAAE,GAAG,CAACL,OAAO,CAACE,SAAS,GAAG,IAAI,CACjD;MACD,MAAMI,OAAO,GAAG,IAAIpB,IAAI,CACtBc,OAAO,CAACH,KAAK,EACbG,OAAO,CAACO,OAAO,EACfP,OAAO,CAACQ,OAAO,EACfL,cAAc,CACf;MACDM,YAAY,CAACC,OAAO,CAAC,UAAU,EAAEC,IAAI,CAACC,SAAS,CAACN,OAAO,CAAC,CAAC;MACzD,OAAO5B,WAAW,CAACmC,kBAAkB,CAAC;QAAEC,IAAI,EAAER;MAAO,CAAE,CAAC;IAC1D,CAAC,CAAC,EACF3B,UAAU,CAAEoC,QAAQ,IAAI;MACtB,IAAIC,YAAY,GAAG,4BAA4B;MAC/C,IAAI,CAACD,QAAQ,CAACE,KAAK,IAAI,CAACF,QAAQ,CAACE,KAAK,CAACA,KAAK,EAAE;QAC5C,OAAOpC,EAAE,CACPH,WAAW,CAACwC,sBAAsB,CAAC;UACjCC,OAAO,EAAEH;SACV,CAAC,CACH;MACH;MACA,QAAQD,QAAQ,CAACE,KAAK,CAACA,KAAK,CAACG,OAAO;QAClC,KAAK,cAAc;UACjBJ,YAAY,GAAG,2BAA2B;UAC1C;QACF,KAAK,iBAAiB;UACpBA,YAAY,GAAG,4BAA4B;UAC3C;QACF,KAAK,kBAAkB;UACrBA,YAAY,GAAG,+BAA+B;UAC9C;MACJ;MACA,OAAOnC,EAAE,CACPH,WAAW,CAACwC,sBAAsB,CAAC;QAAEC,OAAO,EAAEH;MAAY,CAAE,CAAC,CAC9D;IACH,CAAC,CAAC,CACH;EACL,CAAC,CAAC,CACH;AACH,CAAC,EACD;EAAEK,UAAU,EAAE,IAAI;EAAEC,QAAQ,EAAE;AAAI,CAAE,CACrC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}